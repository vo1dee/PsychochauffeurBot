"""
Diagnostics command for system health monitoring and troubleshooting.

This module provides a comprehensive diagnostics command that administrators
can use to check system health, service availability, and recent errors.

Requirements addressed: 3.1, 3.2, 3.3, 3.4, 3.5
"""

import asyncio
import json
from datetime import datetime, timedelta
from typing import Dict, Any, List

from telegram import Update
from telegram.ext import ContextTypes

from modules.enhanced_error_diagnostics import enhanced_diagnostics, get_system_health_report
from modules.command_diagnostics import (
    enhance_command_with_diagnostics,
    validate_command_configuration,
    check_command_dependencies
)
from modules.structured_logging import StructuredLogger, LogLevel
from modules.const import KYIV_TZ


class SystemDiagnosticsCommand:
    """
    Comprehensive system diagnostics command for administrators.
    
    Provides detailed information about:
    - System health and resource usage
    - External service availability
    - Recent errors and their patterns
    - Command execution metrics
    - Configuration validation
    """
    
    def __init__(self) -> None:
        self.logger = StructuredLogger("diagnostics_command")
    
    @enhance_command_with_diagnostics("diagnostics")
    async def diagnostics_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Main diagnostics command handler.
        
        Usage:
        /diagnostics - Full system health report
        /diagnostics quick - Quick health check
        /diagnostics services - Service health only
        /diagnostics errors - Recent errors only
        /diagnostics config - Configuration validation
        /diagnostics commands - Command execution metrics
        """
        if not update.message or not update.effective_user:
            return
        
        # Check if user is authorized (you may want to implement proper admin checks)
        user_id = update.effective_user.id
        
        # Parse command arguments
        args = context.args or []
        report_type = args[0].lower() if args else "full"
        
        # Show initial status message
        status_msg = await update.message.reply_text("üîç –ì–µ–Ω–µ—Ä—É—é –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–∏–π –∑–≤—ñ—Ç...")
        
        try:
            if report_type == "quick":
                report = await self._generate_quick_report()
                formatted_report = self._format_quick_report(report)
            elif report_type == "services":
                report = await self._generate_services_report()
                formatted_report = self._format_services_report(report)
            elif report_type == "errors":
                report = await self._generate_errors_report()
                formatted_report = self._format_errors_report(report)
            elif report_type == "config":
                report = await self._generate_config_report()
                formatted_report = self._format_config_report(report)
            elif report_type == "commands":
                report = await self._generate_commands_report()
                formatted_report = self._format_commands_report(report)
            else:
                # Full report
                report = await get_system_health_report()
                formatted_report = self._format_full_report(report)
            
            # Update status message with results
            await status_msg.edit_text(formatted_report, parse_mode='Markdown')
            
            # Log diagnostics command execution
            self.logger.log_event(
                LogLevel.INFO,
                "diagnostics_command_executed",
                f"Diagnostics command executed by user {user_id}",
                user_id=user_id,
                report_type=report_type,
                chat_id=update.effective_chat.id if update.effective_chat else 0
            )
            
        except Exception as e:
            error_msg = f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–æ–≥–æ –∑–≤—ñ—Ç—É: {str(e)}"
            await status_msg.edit_text(error_msg)
            
            self.logger.log_event(
                LogLevel.ERROR,
                "diagnostics_command_error",
                f"Error generating diagnostics report: {str(e)}",
                user_id=user_id,
                report_type=report_type,
                error=str(e)
            )
    
    async def _generate_quick_report(self) -> Dict[str, Any]:
        """Generate a quick health check report."""
        return {
            "timestamp": datetime.now(KYIV_TZ).isoformat(),
            "service_health": enhanced_diagnostics.get_service_health_summary(),
            "command_metrics": enhanced_diagnostics.get_command_metrics_summary(),
            "system_status": "healthy"  # Simplified for quick check
        }
    
    async def _generate_services_report(self) -> Dict[str, Any]:
        """Generate a detailed services health report."""
        services_health = enhanced_diagnostics.get_service_health_summary()
        
        # Add dependency checks for critical commands
        dependency_checks = {}
        for command in ["analyze", "flares"]:
            dependency_checks[command] = await check_command_dependencies(command)
        
        return {
            "timestamp": datetime.now(KYIV_TZ).isoformat(),
            "services": services_health,
            "command_dependencies": dependency_checks
        }
    
    async def _generate_errors_report(self) -> Dict[str, Any]:
        """Generate a detailed errors report."""
        try:
            from modules.error_analytics import get_error_summary, get_recent_errors
            
            error_summary = get_error_summary()
            recent_errors = get_recent_errors(20)
            
            return {
                "timestamp": datetime.now(KYIV_TZ).isoformat(),
                "error_summary": error_summary,
                "recent_errors": recent_errors
            }
        except Exception as e:
            return {
                "timestamp": datetime.now(KYIV_TZ).isoformat(),
                "error": f"Failed to generate errors report: {str(e)}"
            }
    
    async def _generate_config_report(self) -> Dict[str, Any]:
        """Generate a configuration validation report."""
        config_validations = {}
        
        # Validate configuration for critical commands
        for command in ["analyze", "flares"]:
            config_validations[command] = await validate_command_configuration(command)
        
        return {
            "timestamp": datetime.now(KYIV_TZ).isoformat(),
            "configuration_validations": config_validations
        }
    
    async def _generate_commands_report(self) -> Dict[str, Any]:
        """Generate a command execution metrics report."""
        return {
            "timestamp": datetime.now(KYIV_TZ).isoformat(),
            "command_metrics": enhanced_diagnostics.get_command_metrics_summary(),
            "detailed_metrics": dict(enhanced_diagnostics.command_metrics)
        }
    
    def _format_quick_report(self, report: Dict[str, Any]) -> str:
        """Format quick health check report."""
        services = report.get("service_health", {})
        metrics = report.get("command_metrics", {})
        
        # Count healthy vs unhealthy services
        healthy_services = sum(1 for s in services.values() if s.get("status") == "healthy")
        total_services = len(services)
        
        # Get command success rate
        success_rate = metrics.get("success_rate", 0)
        
        status_emoji = "‚úÖ" if healthy_services == total_services and success_rate > 90 else "‚ö†Ô∏è"
        
        return f"""
{status_emoji} **–®–≤–∏–¥–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å–∏—Å—Ç–µ–º–∏**

üìä **–ó–∞–≥–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω:**
‚Ä¢ –°–µ—Ä–≤—ñ—Å–∏: {healthy_services}/{total_services} –∑–¥–æ—Ä–æ–≤—ñ
‚Ä¢ –ö–æ–º–∞–Ω–¥–∏: {success_rate:.1f}% —É—Å–ø—ñ—à–Ω–∏—Ö
‚Ä¢ –ß–∞—Å –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏: {datetime.now(KYIV_TZ).strftime('%H:%M %d.%m.%Y')}

üí° –î–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ:
‚Ä¢ `/diagnostics services` - —Å—Ç–∞–Ω —Å–µ—Ä–≤—ñ—Å—ñ–≤
‚Ä¢ `/diagnostics errors` - –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–º–∏–ª–∫–∏
‚Ä¢ `/diagnostics config` - –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
        """.strip()
    
    def _format_services_report(self, report: Dict[str, Any]) -> str:
        """Format services health report."""
        services = report.get("services", {})
        dependencies = report.get("command_dependencies", {})
        
        lines = ["üîß **–°—Ç–∞–Ω —Å–µ—Ä–≤—ñ—Å—ñ–≤**", ""]
        
        # Service health
        for service_name, health in services.items():
            status = health.get("status", "unknown")
            emoji = "‚úÖ" if status == "healthy" else "‚ùå" if status == "unhealthy" else "‚ö†Ô∏è"
            
            response_time = health.get("response_time_ms")
            time_str = f" ({response_time:.0f}ms)" if response_time else ""
            
            availability = health.get("availability_percent", 0)
            
            lines.append(f"{emoji} **{service_name}**: {status}{time_str}")
            lines.append(f"   –î–æ—Å—Ç—É–ø–Ω—ñ—Å—Ç—å: {availability:.1f}%")
            
            if health.get("consecutive_failures", 0) > 0:
                lines.append(f"   –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ –∑–±–æ—ó: {health['consecutive_failures']}")
            
            lines.append("")
        
        # Command dependencies
        if dependencies:
            lines.append("üîó **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ –∫–æ–º–∞–Ω–¥:**")
            lines.append("")
            
            for command, deps in dependencies.items():
                healthy = deps.get("healthy", False)
                emoji = "‚úÖ" if healthy else "‚ùå"
                lines.append(f"{emoji} **{command}**: {'–∑–¥–æ—Ä–æ–≤—ñ' if healthy else '–ø—Ä–æ–±–ª–µ–º–∏'}")
                
                for dep_name, dep_info in deps.get("dependencies", {}).items():
                    dep_healthy = dep_info.get("healthy", False)
                    dep_emoji = "‚úÖ" if dep_healthy else "‚ùå"
                    lines.append(f"   {dep_emoji} {dep_name}")
                
                lines.append("")
        
        return "\n".join(lines)
    
    def _format_errors_report(self, report: Dict[str, Any]) -> str:
        """Format errors report."""
        if "error" in report:
            return f"‚ùå **–ü–æ–º–∏–ª–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –∑–≤—ñ—Ç—É –ø—Ä–æ –ø–æ–º–∏–ª–∫–∏**\n\n{report['error']}"
        
        summary = report.get("error_summary", {})
        recent_errors = report.get("recent_errors", [])
        
        lines = ["üö® **–ó–≤—ñ—Ç –ø—Ä–æ –ø–æ–º–∏–ª–∫–∏**", ""]
        
        # Error summary
        total_errors = summary.get("total_errors", 0)
        lines.append(f"üìä **–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**")
        lines.append(f"‚Ä¢ –í—Å—å–æ–≥–æ –ø–æ–º–∏–ª–æ–∫: {total_errors}")
        
        # By category
        by_category = summary.get("by_category", {})
        if by_category:
            lines.append(f"‚Ä¢ –ó–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—è–º–∏:")
            for category, count in by_category.items():
                lines.append(f"  - {category}: {count}")
        
        # By severity
        by_severity = summary.get("by_severity", {})
        if by_severity:
            lines.append(f"‚Ä¢ –ó–∞ –≤–∞–∂–ª–∏–≤—ñ—Å—Ç—é:")
            for severity, count in by_severity.items():
                lines.append(f"  - {severity}: {count}")
        
        lines.append("")
        
        # Recent errors
        if recent_errors:
            lines.append("üïê **–û—Å—Ç–∞–Ω–Ω—ñ –ø–æ–º–∏–ª–∫–∏:**")
            lines.append("")
            
            for error in recent_errors[:10]:  # Show last 10 errors
                timestamp = error.get("timestamp", "")
                if timestamp:
                    try:
                        dt = datetime.fromisoformat(timestamp)
                        time_str = dt.strftime("%H:%M %d.%m")
                    except:
                        time_str = timestamp[:16]
                else:
                    time_str = "Unknown"
                
                category = error.get("category", "unknown")
                severity = error.get("severity", "unknown")
                message = error.get("message", "No message")[:100]
                
                lines.append(f"‚Ä¢ `{time_str}` [{category}/{severity}]")
                lines.append(f"  {message}")
                lines.append("")
        
        return "\n".join(lines)
    
    def _format_config_report(self, report: Dict[str, Any]) -> str:
        """Format configuration validation report."""
        validations = report.get("configuration_validations", {})
        
        lines = ["‚öôÔ∏è **–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó**", ""]
        
        for command, validation in validations.items():
            valid = validation.get("valid", False)
            emoji = "‚úÖ" if valid else "‚ùå"
            
            lines.append(f"{emoji} **–ö–æ–º–∞–Ω–¥–∞ {command}**: {'OK' if valid else '–ü—Ä–æ–±–ª–µ–º–∏'}")
            
            issues = validation.get("issues", [])
            if issues:
                lines.append("   –ü—Ä–æ–±–ª–µ–º–∏:")
                for issue in issues:
                    lines.append(f"   ‚Ä¢ {issue}")
            
            warnings = validation.get("warnings", [])
            if warnings:
                lines.append("   –ü–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è:")
                for warning in warnings:
                    lines.append(f"   ‚ö†Ô∏è {warning}")
            
            lines.append("")
        
        return "\n".join(lines)
    
    def _format_commands_report(self, report: Dict[str, Any]) -> str:
        """Format command execution metrics report."""
        metrics = report.get("command_metrics", {})
        
        lines = ["üìà **–ú–µ—Ç—Ä–∏–∫–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∫–æ–º–∞–Ω–¥**", ""]
        
        total_commands = metrics.get("total_commands", 0)
        successful_commands = metrics.get("successful_commands", 0)
        failed_commands = metrics.get("failed_commands", 0)
        success_rate = metrics.get("success_rate", 0)
        avg_duration = metrics.get("average_duration_seconds", 0)
        
        lines.append(f"üìä **–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**")
        lines.append(f"‚Ä¢ –í—Å—å–æ–≥–æ –∫–æ–º–∞–Ω–¥: {total_commands}")
        lines.append(f"‚Ä¢ –£—Å–ø—ñ—à–Ω–∏—Ö: {successful_commands}")
        lines.append(f"‚Ä¢ –ù–µ–≤–¥–∞–ª–∏—Ö: {failed_commands}")
        lines.append(f"‚Ä¢ –£—Å–ø—ñ—à–Ω—ñ—Å—Ç—å: {success_rate:.1f}%")
        lines.append(f"‚Ä¢ –°–µ—Ä–µ–¥–Ω—ñ–π —á–∞—Å: {avg_duration:.3f}—Å")
        lines.append("")
        
        # Command counts
        command_counts = metrics.get("command_counts", {})
        if command_counts:
            lines.append("üî¢ **–ó–∞ –∫–æ–º–∞–Ω–¥–∞–º–∏:**")
            for command, count in sorted(command_counts.items(), key=lambda x: x[1], reverse=True):
                lines.append(f"‚Ä¢ {command}: {count}")
            lines.append("")
        
        return "\n".join(lines)
    
    def _format_full_report(self, report: Dict[str, Any]) -> str:
        """Format comprehensive system health report."""
        lines = ["üè• **–ü–æ–≤–Ω–∏–π –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–∏–π –∑–≤—ñ—Ç**", ""]
        
        # System state
        system_state = report.get("system_state", {})
        if system_state:
            lines.append("üíª **–°—Ç–∞–Ω —Å–∏—Å—Ç–µ–º–∏:**")
            lines.append(f"‚Ä¢ CPU: {system_state.get('cpu_usage', 0):.1f}%")
            lines.append(f"‚Ä¢ –ü–∞–º'—è—Ç—å: {system_state.get('memory_usage', 0):.1f} MB")
            lines.append(f"‚Ä¢ –î–∏—Å–∫: {system_state.get('disk_usage', 0):.1f}%")
            lines.append("")
        
        # Service health summary
        service_health = report.get("service_health", {})
        if service_health:
            healthy_services = sum(1 for s in service_health.values() if s.get("status") == "healthy")
            total_services = len(service_health)
            
            lines.append(f"üîß **–°–µ—Ä–≤—ñ—Å–∏:** {healthy_services}/{total_services} –∑–¥–æ—Ä–æ–≤—ñ")
            
            for service_name, health in service_health.items():
                status = health.get("status", "unknown")
                emoji = "‚úÖ" if status == "healthy" else "‚ùå"
                lines.append(f"   {emoji} {service_name}")
            
            lines.append("")
        
        # Command metrics summary
        command_metrics = report.get("command_metrics", {})
        if command_metrics:
            success_rate = command_metrics.get("success_rate", 0)
            total_commands = command_metrics.get("total_commands", 0)
            
            lines.append(f"üìà **–ö–æ–º–∞–Ω–¥–∏:** {success_rate:.1f}% —É—Å–ø—ñ—à–Ω–∏—Ö ({total_commands} –≤—Å—å–æ–≥–æ)")
            lines.append("")
        
        # Recent errors summary
        recent_errors = report.get("recent_errors", [])
        if recent_errors:
            lines.append(f"üö® **–û—Å—Ç–∞–Ω–Ω—ñ –ø–æ–º–∏–ª–∫–∏:** {len(recent_errors)}")
            for error in recent_errors[:5]:  # Show last 5 errors
                timestamp = error.get("timestamp", "")
                if timestamp:
                    try:
                        dt = datetime.fromisoformat(timestamp)
                        time_str = dt.strftime("%H:%M")
                    except:
                        time_str = "??:??"
                else:
                    time_str = "??:??"
                
                category = error.get("category", "unknown")
                lines.append(f"   ‚Ä¢ {time_str} [{category}]")
            
            lines.append("")
        
        # Configuration status
        config_status = report.get("configuration_status", {})
        if config_status:
            valid = config_status.get("valid", False)
            emoji = "‚úÖ" if valid else "‚ùå"
            lines.append(f"{emoji} **–ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è:** {'OK' if valid else '–ü—Ä–æ–±–ª–µ–º–∏'}")
            
            issues = config_status.get("issues", [])
            if issues:
                for issue in issues[:3]:  # Show first 3 issues
                    lines.append(f"   ‚Ä¢ {issue}")
            
            lines.append("")
        
        lines.append(f"üïê **–ß–∞—Å –∑–≤—ñ—Ç—É:** {datetime.now(KYIV_TZ).strftime('%H:%M %d.%m.%Y')}")
        
        return "\n".join(lines)


# Global instance
system_diagnostics = SystemDiagnosticsCommand()


# Export the command handler
async def diagnostics_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Diagnostics command handler for external use."""
    await system_diagnostics.diagnostics_command(update, context)